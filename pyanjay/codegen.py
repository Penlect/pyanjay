#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright 2017-2020 AVSystem <avsystem@avsystem.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import argparse
import collections
import textwrap
import operator
import os
import pathlib
import sys
import re
from xml.etree import ElementTree
from xml.etree.ElementTree import Element
from typing import Mapping, Tuple, Optional

# PyPI
try:
    from jinja2 import Environment
except ModuleNotFoundError as error:
    sys.exit("Dependency jinja2 is needed to run this tool. "
             "Try 'python3 -m pip install --user jinja2'.")

PY_TEMPLATE = """\
\"\"\"Generated by pyanjay.codegen.py on {{ date_time }}

LwM2M Object: {{ obj.name }}
ID: {{ obj.oid }}, URN: {{ obj.urn }}, {{ obj.mandatory_str }}, {{ obj.multiple_str }}

{{ obj.description }}
\"\"\"

from pyanjay.dm import *

{% for res in obj.resources %}
@ID({{res.rid}})
class {{ res.name_class }}({{res.operations}}):
    \"\"\"{{ res.name }} - {{ res.type|title }}, {{ res.multiple_str }}, {{ res.mandatory_str }}

{% if res.description %}
    {{ res.description }}
{% endif %}
    \"\"\"

    type = '{{ res.type }}'
    range = '{{ res.range_enumeration }}'
    unit = '{{ res.units }}'
    mandatory = {{ res.mandatory }}
    multiple = {{ res.multiple }}

{% endfor %}
@ID({{ obj.oid }})
class {{ obj.name_class }}(ObjectDef):
    \"\"\"{{ obj.name }} Object - {{ obj.mandatory_str }}, {{ obj.multiple_str }}

    {{ obj.description }}
    \"\"\"

    mandatory = {{ obj.mandatory }}
    multiple = {{ obj.multiple }}
{% for res in obj.resources %}

    # ID={{ res.rid }}, {{ res.type|title }}, {{ res.operations }}, {{ res.multiple_str }}, {{ res.mandatory_str }}, range: {{ res.range_enumeration }}, unit: {{ res.units }}
    {{ res.name_snake }} = {{ res.name_class }}({{ res.default_value }})
{% endfor %}


# Todo: __main__ hello world
"""

INIT_TEMPLATE = """\
\"\"\"Generated by pyanjay.codegen.py on {{ date_time }}\"\"\"

{% for obj in objs %}
from .{{ obj.name_module }} import {{ obj.name_class }}
{% endfor %}

__all__ = [
{% for obj in objs %}
    '{{ obj.name_class }}',
{% endfor %}
]
"""

def _node_text(n: Element) -> str:
    return (n.text if n.text is not None else '').strip()


def _sanitize_macro_name(n: str) -> str:
    return re.sub(r'[^a-zA-Z0-9]+', '_', n).strip('_')

def _sanitize_snake_name(n: str) -> str:
    return re.sub(r'[^a-zA-Z0-9]+', '_', n).strip('_').lower()

def _sanitize_class_name(n: str) -> str:
    name = re.sub(r'[^a-zA-Z0-9]+', '_', n).strip('_').lower()
    name = name.title()
    name = name.replace('_', '')
    return name

class ResourceDef(collections.namedtuple('ResourceDef', ['rid', 'name', 'operations', 'multiple', 'mandatory', 'type',
                                                         'range_enumeration', 'units', 'description'])):
    @property
    def mandatory_str(self) -> str:
        return 'Mandatory' if self.mandatory else 'Optional'

    @property
    def multiple_str(self):
        return 'Multiple' if self.multiple else 'Single'

    @property
    def name_class(self) -> str:
        return _sanitize_class_name(self.name)

    @property
    def name_snake(self) -> str:
        return _sanitize_snake_name(self.name)

    @property
    def default_value(self) -> str:
        types = [
            (('boolean', 'bool'), 'False'),
            (('integer', 'int'), '0'),
            (('float',), '0.0'),
            (('corelnk', 'string', 'str'), '""'),
            # (('opaque',), '???'),
            # (('time',), '???'),
            # (('objlnk',), '???'),
            (('unsigned integer',
              'unsigned int',
              'unsigned'), '0')
        ]
        for match_types, value in types:
            if self.type.lower() in match_types:
                return value
        return 'None'

    @property
    def name_upper(self) -> str:
        return _sanitize_macro_name('RID_' + self.name.upper())

    @property
    def kind_enum(self) -> str:
        if self.operations not in {'R', 'W', 'RW', 'E', 'BS_RW'}:
            raise AssertionError('unexpected operations: ' + self.operations)
        result = 'ANJAY_DM_RES_' + self.operations
        if self.multiple:
            if 'E' in self.operations:
                raise AssertionError('multiple-instance executable resources are not supported')
            result += 'M'
        return result

    @property
    def read_handler(self) -> Optional[str]:
        assert 'R' in self.operations

        types = [
            (('boolean', 'bool'), 'anjay_ret_bool(%s, 0)'),
            (('integer', 'int'),  'anjay_ret_i32(%s, 0)'),
            (('float',),          'anjay_ret_float(%s, 0)'),
            (('corelnk', # TODO T2033
              'string', 'str'),   'anjay_ret_string(%s, "")'),
            (('opaque',),         'anjay_ret_bytes(%s, "", 0)'),
            (('time',),           'anjay_ret_i64(%s, 0)'),
            (('objlnk',),         'anjay_ret_objlnk(%s, 0, 0)'),
            (('unsigned integer',
              'unsigned int',
              'unsigned'),        'anjay_ret_u32(%s, 0)')
        ]

        def get_ret_func(type):
            for match_types, ret_func in types:
                if type in match_types:
                    return ret_func
            else:
                raise AssertionError('unexpected type: ' + type)

        if not self.multiple:
            return textwrap.indent(textwrap.dedent("""
                    assert(riid == ANJAY_ID_INVALID);
                    return %s; // TODO"""), '    ') % (get_ret_func(self.type) % ('ctx',))
        else:
            return textwrap.indent(textwrap.dedent("""
                    // TODO: extract Resource Instance
                    return %s; // TODO"""), '    ') % (get_ret_func(self.type) % ('ctx',))


    @property
    def write_handler(self) -> Optional[Tuple[str, str]]:
        assert 'W' in self.operations

        types = [
            (('boolean', 'bool'), 'bool value',      'anjay_get_bool(%s, &value)'),
            (('integer', 'int'),  'int32_t value',   'anjay_get_i32(%s, &value)'),
            (('float',),          'float value',     'anjay_get_float(%s, &value)'),
            (('corelnk', # TODO T2033
              'string', 'str'),   'char value[256]', 'anjay_get_string(%s, value, sizeof(value))'),
            (('opaque',),
                 'uint8_t value[256];\n'
                 '    bool finished;\n'
                 '    size_t bytes_read',
                 'anjay_get_bytes(%s,\n'
                 '                           &bytes_read,\n'
                 '                           &finished,\n'
                 '                           value,\n'
                 '                           sizeof(value))'),
            (('time',),           'int64_t value',   'anjay_get_i64(%s, &value)'),
            (('objlnk',),
                'anjay_oid_t objlnk_oid;\n'
                '    anjay_iid_t objlnk_iid',
                'anjay_get_objlnk(%s, &objlnk_oid, &objlnk_iid)'),
            (('unsigned integer',
              'unsigned int',
              'unsigned'),        'uint32_t value',  'anjay_get_u32(%s, &value)')
        ]

        def get_get_func(type):
            for match_types, alloc_value, get_func in types:
                if type in match_types:
                    return alloc_value, get_func
            else:
                raise AssertionError('unexpected type: ' + type)

        local_def, get_func = get_get_func(self.type.lower())
        get_func %= ('ctx',)
        if not self.multiple:
            return ' ' + textwrap.dedent("""\
                    {
                        assert(riid == ANJAY_ID_INVALID);
                        %s; // TODO
                        return %s; // TODO
                    }""") % (local_def, get_func)
        else:
            return ' ' + textwrap.dedent("""\
                    {
                        // TODO: extract Resource Instance
                        %s; // TODO
                        return %s; // TODO
                    }""") % (local_def, get_func)

    @classmethod
    def from_etree(cls, res: Element) -> 'ResourceDef':
        return cls(rid=int(res.get('ID')),
                   name=_node_text(res.find('Name')),
                   operations=_node_text(res.find('Operations')).upper()
                       or 'BS_RW', # no operations = resource modifiable by Bootstrap Server
                   multiple={'Single': False, 'Multiple': True}[_node_text(res.find('MultipleInstances'))],
                   mandatory={'Optional': False, 'Mandatory': True}[_node_text(res.find('Mandatory'))],
                   type=(_node_text(res.find('Type')).lower() or 'N/A'),
                   range_enumeration=(_node_text(res.find('RangeEnumeration')) or 'N/A'),
                   units=(_node_text(res.find('Units')) or 'N/A'),
                   description=textwrap.fill(_node_text(res.find('Description'))))


class ObjectDef(collections.namedtuple('ObjectDef',
                                       ['oid', 'name', 'description', 'urn', 'multiple', 'mandatory', 'resources'])):
    @property
    def name_snake(self) -> str:
        return _sanitize_snake_name(self.name)

    @property
    def name_module(self) -> str:
        return f'{self.name_snake}_{self.oid}'

    @property
    def name_class(self) -> str:
        return _sanitize_class_name(self.name)

    @property
    def name_pascal(self) -> str:
        return ''.join(word.capitalize() for word in self.name.split())

    @property
    def mandatory_str(self) -> str:
        return 'Mandatory' if self.mandatory else 'Optional'

    @property
    def multiple_str(self):
        return 'Multiple' if self.multiple else 'Single'

    @property
    def has_any_readable_resources(self) -> bool:
        return any('R' in res.operations for res in self.resources)

    @property
    def has_any_writable_resources(self) -> bool:
        return any('W' in res.operations for res in self.resources)

    @property
    def has_any_executable_resources(self) -> bool:
        return any('E' in res.operations for res in self.resources)

    @property
    def has_any_multiple_resources(self) -> bool:
        return any(res.multiple for res in self.resources)

    @property
    def has_any_multiple_writable_resources(self) -> bool:
        return any((res.multiple and 'W' in res.operations) for res in self.resources)

    @property
    def needs_instance_reset_handler(self) -> bool:
        return self.multiple or self.has_any_writable_resources

    @staticmethod
    def parse_resources(obj: ElementTree):
        return sorted([ResourceDef.from_etree(item) for item in obj.find('Resources').findall('Item')],
                       key=operator.attrgetter('rid'))

    @classmethod
    def from_etree(cls, obj: ElementTree, resources_subset: set) -> 'ObjectDef':
        resources = ObjectDef.parse_resources(obj)
        if resources_subset is not None:
            resources = [ r for r in resources if r.rid in resources_subset ]

        return cls(name=_node_text(obj.find('Name')),
                   description=textwrap.fill(_node_text(obj.find('Description1'))),
                   oid=int(_node_text(obj.find('ObjectID'))),
                   urn=_node_text(obj.find('ObjectURN')),
                   multiple={'Single': False, 'Multiple': True}[_node_text(obj.find('MultipleInstances'))],
                   mandatory={'Optional': False, 'Mandatory': True}[_node_text(obj.find('Mandatory'))],
                   resources=resources)


def generate_object_boilerplate(obj):

    jinja_env = Environment(trim_blocks=True)

    handlers = []
    if obj.multiple:
        handlers.append(('list_instances', 'list_instances'))
        handlers.append(('instance_create', 'instance_create'))
        handlers.append(('instance_remove', 'instance_remove'))
    else:
        handlers.append(('list_instances', 'anjay_dm_list_instances_SINGLE'))

    if obj.needs_instance_reset_handler:
        handlers.append(('instance_reset', 'instance_reset'))

    handlers.append('')
    handlers.append(('list_resources', 'list_resources'))
    if obj.has_any_readable_resources:
        handlers.append(('resource_read', 'resource_read'))
    if obj.has_any_writable_resources:
        handlers.append(('resource_write', 'resource_write'))
    if obj.has_any_executable_resources:
        handlers.append(('resource_execute', 'resource_execute'))
    if obj.has_any_multiple_writable_resources:
        handlers.append(('resource_reset', 'resource_reset'))
    if obj.has_any_multiple_resources:
        handlers.append(('list_resource_instances', 'list_resource_instances'))

    handlers.append('')
    handlers.append('// TODO: implement these if transactional write/create is required')
    handlers.append(('transaction_begin', 'anjay_dm_transaction_NOOP'))
    handlers.append(('transaction_validate', 'anjay_dm_transaction_NOOP'))
    handlers.append(('transaction_commit', 'anjay_dm_transaction_NOOP'))
    handlers.append(('transaction_rollback', 'anjay_dm_transaction_NOOP'))

    return (jinja_env.from_string(PY_TEMPLATE)
                .render(obj=obj,
                        handlers=handlers,
                        date_time=datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        obj_name_snake=obj.name_snake,
                        obj_repr_tag=obj.name_snake + '_object_struct',
                        obj_repr_type=obj.name_snake + '_object_t',
                        obj_inst_tag=obj.name_snake + '_instance_struct',
                        obj_inst_type=obj.name_snake + '_instance_t',
                        obj_cxx_type=obj.name_pascal + 'Object',
                        obj_inst_cxx_type=obj.name_pascal + 'Instance'))

def generate_init_py(objects):
    jinja_env = Environment(trim_blocks=True)
    return (jinja_env.from_string(INIT_TEMPLATE)
                .render(objs=objects,
                        date_time=datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog='python3 -m pyanjay.codegen',
        description='Parses an LwM2M object definition XML and '
                    'generates Python skeleton.')
    parser.add_argument(
        'input',
        nargs='*',
        help='Input XML files or non to read from stdin.')
    parser.add_argument(
        '-o', '--output', default='/dev/stdout',
        help='Output filename or output directory. (default: stdout)')
    parser.add_argument(
        '-f', '--force', action='store_true',
        help='Overwrite exiting output files.')
    parser.add_argument(
        '-l', '--list',
        help='List resources and their names only.', action='store_true')
    parser.add_argument(
        '-r', '--resources', nargs='+', type=int,
        help='Generate code only for a specific list of resources. '
             'If the resource does not exist it is silently ignored.')

    args = parser.parse_args()
    mode = 'w' if args.force else 'x'
    output_is_dir = os.path.isdir(args.output)
    output_is_stdout = not args.output
    inputs = set(args.input)
    input_is_stdin = not inputs
    if input_is_stdin:
        args.input = sys.stdin
    if output_is_stdout:
        args.output = sys.stdout

    # If any input is a directory, take all xml-files in it.
    xmlfiles = list()
    for file in inputs:
        file = pathlib.Path(file)
        if file.is_dir():
            for f in file.iterdir():
                if f.suffix.lower() == '.xml':
                    xmlfiles.append(f)
        else:
            xmlfiles.append(file)
    if len(xmlfiles) > 1 and not output_is_dir:
        sys.exit(
            'Output must be directory if multiple xml files are provided.')

    objects = list()
    for xmlfile in xmlfiles:
        if not output_is_stdout:
            print(xmlfile)
        # Read input file
        with open(xmlfile) as f:
            tree = ElementTree.fromstring(f.read())

        # Parse object
        xmlobj = tree.find('Object')
        if args.list:
            for r in ObjectDef.parse_resources(xmlobj):
                print(r.rid, r.name, '(mandatory)' if r.mandatory else '')
            continue
        obj = ObjectDef.from_etree(xmlobj, args.resources)
        objects.append(obj)

        # Render template
        boilerplate = generate_object_boilerplate(obj)

        # Save Python skeleton to output file
        if output_is_dir:
            filename = os.path.join(args.output,
                                    f'{obj.name_module}.py')
        else:
            filename = args.output
        if not output_is_stdout:
            print(filename)
        with open(filename, mode) as f:
            print(boilerplate, file=f)
    if output_is_dir:
        content = generate_init_py(objects)
        with open(os.path.join(args.output, '__init__.py'), mode) as f:
            print(content, file=f)
